# CRUD Quiz

Use the solution to this afternoon's Property Tracker lab to answer the following questions. Please write your answers under each question, push the file to GitHub, and submit in the usual way.

## MVP Questions

In our Property Tracker application:

Q1. Where are we instantiating instances of the `Property` class?

Instances of the property class are being created in the console.rb file.

Q2. Where are we defining the SQL that enables us to save the ruby `Property` object into the database?

The SQL is being defined in an SQL file stored in the directory called db - however, SQL is being used inside the method in the property.rb file so as to allow the Property object to enter into the SQL database. This is being done through a method called "save".

Q3. In `console.rb`, which lines modify the database?

property1.delete()
All objects created as Property.new objects
Property.delete_all() - in its own way, by clearing the contents of the table before populating it with new data.

Q4. Why do we not define the id of a `Property` object at the point we instantiate it (‘new it up’)?

The SQL database has automatic id creation within it through id SERIAL4 PRIMARY KEY. This will generate a unique id for every item of data.

Q5. Where and how do we assign the id (that is generated by the database) to the ruby `Property` object?

We assign the ID from the SQL file - when the property object is passed into the properties.sql file we pin the id that the SQL file generates to the object using this code: @id = db.exec_prepared("save", values)[0]["id"].to_i

Q6. Why do we put a guard (an `if` clause) on the `@id` attribute in the constructor?

In case an id is not appended, which would result in 0. We do not want 0 as an id as it may be used by others/programs as a legitimate form of identification.

Q7. Why are some of the CRUD actions represented by instance methods, and others by class methods?

Some methods relate directly to an instance of data, such as delete and update. These are instance methods as they allow us to edit our data more specifically. Instance methods should not be able to manipulate all data in a database, as they are methods related to specific items of data. Class methods should have greater control over more than one instance, allowing us to return more than one item of data.

Q8. What type of data structure is returned by calls to `db.exec_prepared()`? In the `save` method, how do we access the id from the returned data structure?

Calls to `db.exec_prepared()` within save drill down and isolate the id generated by the sql file, this is initially returned as a string, which is then converted to an integer through .to_i. following conversion the ID is then pinned to @id and then passed through the initialiser of the class, which then allows for the id to pass into the hash within the Property class.

Q9. Why do we use prepared statements when performing database operations?

Prepared statements are resistant to sql injection - which is when a user inputs a line of sql directly into the data. Without the prepared statement, the sql input by the user would be entered directly into the code and run, potentially leading to data damage and/or loss.

## Extension Questions

Look at the `find_by_id` and `find_by_address` methods in the `Property` class.

Q10. What do they take in as their arguments?

Property.find takes in an id from the user, and Property.find_by_address takes in an address from the user.

Q11. What are their return values?

Property.find runs 'SELECT * FROM properties WHERE id = $1' where $1 is the argument being passed into the method by the user. If the number passed by the user was 1, then all data regarding property1 would be returned.

Property.find_by_address runs 'SELECT * from properties WHERE address = $1' where $1 is the argument being passed into the method by the user. If the number passed by the user was 89 Bouverie Road, then all data regarding property1 would be returned.
